
  #include "stdafx.h"
#include<iostream>

template<class T>
class Element
{
	T data;
	Element<T> next;
	Element(const T&_data, Element<T>*_next) :data(_data), next(_next) {}
};
template<class T>
class List
{
private:
	Element<T>* first;
	Element<T>* last;
	int count;
	void cpy(const List<T>&);
	void erase();
public:
	List();
	List(const List<T>&);
	List& operator=(const List<T>&);
	~List();
	
	  ///// to do
    void pushBack(const T& inf);
	void pushFront(T inf);
	void pushAfter(int pos, const T& inf);
	void popBack();
	void popFront();
	void removeAt(T inf);
	T& getFromPos(int index);
	T& operator[] (int pos);
	bool member(const T& other);
	void sort();
        int getCount()const;
 


};
template<class T>
void List<T>::cpy(const List<T>&other)
{
	Element<T>* curr = other.first;
	while (curr != nullptr)
	{
		pushBack(curr->data);
		curr = curr->next;
	}
}
template<class T>
void List<T>::erase()
{
	Element<T>* curr;
	while (first != nullptr)
	{
		curr = first;
		first = first->next;
		delete curr;
	}
	first = last = nullpte;
	count = 0;
}
template<class T>
List<T>::List ()
{
	first = nullptr;
	last = nullptr;
	count = 0;
}
template<class T>
List<T>::List(const List<T> &other)
{
	cpy(other);
}
template<class T>
List<T>& List<T>:: operator=(const List<T>&other)
{
	if (first == other.first) return *this;
	erase();
	cpy(other);
	return*this;
}
template<class T>
List<T>::~List()
{
	erase();
}

template<class T>
void reverse(Element<T> *&start)
{
	Element<T>*previous = nullptr;
	Element<T>*current = start;
	Element<T>*incoming;
	while (current)
	{
		incoming = current->next;
		current->next = previous;
		previous = current;
		current = incoming;
	}
	start = previous;
}
  
  
  
