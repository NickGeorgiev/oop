// list.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"
#include<iostream>

template<class T>
class Element
{
	T data;
	Element<T> next;
	Element(const T&_data, Element<T>*_next) :data(_data), next(_next) {}
};
template<class T>
class List
{
private:
	Element<T>* first;
	Element<T>* last;
	Element<T>* current;

	int count;
	void cpy(const List<T>&);
	void erase();
public:
	List();
	List(const List<T>&);
	List& operator=(const List<T>&);
	~List();
	void ascending(Element<T>);
	void reverse(Element<T> *&);
	List<T> merge(Element<T>, Element<T>);
	List<T> merge2(List<T>, List<T>);
	void iterator(Element<T>*);
	Element<T>* iter();
	void toEnd(const T &);
	List<T> map(T(*f)(T), List<T> &l);
	List<T> filter(bool(*p)(T), List<T> &l);
	T accumulate(T(*oper)(T, T), T nvalue, List<T> &l);


	///// to do
	void pushBack(const T& inf);
	void pushFront(T inf);
	void pushAfter(int pos, const T& inf);
	void popBack();
	void popFront();
	void removeAt(T inf);
	T& getFromPos(int index);
	T& operator[] (int pos);
	bool member(const T& other);
	void sort();
	int getCount()const;



};
template<class T>
void List<T>::cpy(const List<T>&other)
{
	Element<T>* curr = other.first;
	while (curr != nullptr)
	{
		pushBack(curr->data);
		curr = curr->next;
	}
}
template<class T>
void List<T>::erase()
{
	Element<T>* curr;
	while (first != nullptr)
	{
		curr = first;
		first = first->next;
		delete curr;
	}
	first = last = nullptr;
	count = 0;
}
template<class T>
List<T>::List()
{
	first = nullptr;
	last = nullptr;
	count = 0;
}
template<class T>
List<T>::List(const List<T> &other)
{
	cpy(other);
}
template<class T>
List<T>& List<T>:: operator=(const List<T>&other)
{
	if (first == other.first) return *this;
	erase();
	cpy(other);
	return*this;
}
template<class T>
List<T>::~List()
{
	erase();
}

template<class T>
void List<T>::reverse(Element<T> *&start)
{
	Element<T>*previous = nullptr;
	Element<T>*current = start;
	Element<T>*incoming;
	while (current)
	{
		incoming = current->next;
		current->next = previous;
		previous = current;
		current = incoming;
	}
	start = previous;
}
template<class T>
void List<T>::ascending(Element<T> one) //direct selection
{
	Element<T>*current = one.start;
	Element<T>*incoming = current->next;
	Element<T>*helper;
	while (incoming)
	{
		if (current->data > incoming->data)
		{
			helper = current;
			current = incoming;
			incoming = helper;
		}
		current = current->next;
	}
}
template<class T>
List<T> List<T>::merge(Element<T> one, Element<T> other) //we accept that for other(list) we do not know if it is sorted :D
{
	Element<T>*current = other.start;
	while (current->next)
	{
		ascending(other); // sort the other list :D
	}
	Element<T>* last;
	while (current->next)
	{
		last = current->next;
		current = current->next;
	}
	last->next = other.start; //we connect the two lists :)
	while (current->next)
	{
		ascending(last);
	}
}

template<class T>
List<T> List<T>::merge2(List<T> a, List<T> b)
{
	List<T>* result;
	result = new List<T>();
	if (a->data <= b->data)
		result = a;
	else
		result = b;
	Node *first = a, *second = b;
	while (a && b) {
		if (first->data <= second->data) {
			if (first->next == nullptr)
				break;
			a = first->next;
			if (first->next->data > second->next)
				first->next = second;
			first = a;
		}
		else {
			if (second->next == nullpte)
				break;
			b = second->next;
			if (second->next->data >= first->data)
				second->next = first;
			second = b;
		}
	}
	if (first->next == nulltr)
		first->next = second;
	else
		second->next = first;
	return result;
}

template<class T>
void List<T>::toEnd(const T & el) //insert el(element) to the end of the list 
{
	Element<T> *p = end;
	end = new Element<T>;
	if (end)
	{
		end->data = el;
		end->next = nullptr;
	}
	if (p)		p->data = end;
	else		start = end;

}
template<class T>
void List<T>::iterator(Element<T>* p)//initialization of Iterator
{
	if (p)
		current = p;
	else
	{
		current = start;
	}
}

template<class T>
Element<T>* List<T>::iter() //returns current positiion of iterator and moves it with one position
{
	Element<T>*p = current;
	if (current)
	{
		current = current->next;
	}
	return p;
}
template<class T>
List<T> List<T>::map(T(*f)(T), List<T> &l)
{
	l.iterator();
	Element<T>* p = l.iter();
	List<T> l1;
	while (p)
	{
		l1.toEnd(f(p->data)); //toEnd to write
		p = p->next;
	}
	return l1;
}
template<class T>
List<T> List<T>::filter(bool(*p)(T), List<T> &l)
{
	List<T> l1;
	l.iterator();
	Element<T>* recent = l.iter();
	while (recent)
	{
		if (p(recent->data))
			l1.toEnd(p->data);
		p = p->next;
	}
	return l1;
}
template<class T>
T List<T>::accumulate(T(*oper)(T, T), T nvalue, List<T> &l)
{
	T s = nvalue;
	l.iterator();
	Element<T>* recent = l.iter();
	while (recent)
	{
		s = oper(s, recent->data);
		recent = recent->next;
	}
	return s;
}

int main()
{

	return 0;
}
