// list.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"
#include<iostream>

template<class T>
class Element
{
	T data;
	Element<T> next;
	Element(const T&_data, Element<T>*_next) :data(_data), next(_next) {}
};
template<class T>
class List
{
private:
	Element<T>* first;
	Element<T>* last;
	Element<T>* current;

	int count;
	void cpy(const List<T>&);
	void erase();
public:
	List();
	List(const List<T>&);
	List& operator=(const List<T>&);
	~List();
	void ascending(Element<T>);
	void reverse(Element<T> *&);
	List<T> merge(Element<T>, Element<T>);
	void iterator(Element<T>*);
	Element<T>* iter();
	///// to do
	void pushBack(const T& inf);
	void pushFront(T inf);
	void pushAfter(int pos, const T& inf);
	void popBack();
	void popFront();
	void removeAt(T inf);
	T& getFromPos(int index);
	T& operator[] (int pos);
	bool member(const T& other);
	void sort();
	int getCount()const;



};
template<class T>
void List<T>::cpy(const List<T>&other)
{
	Element<T>* curr = other.first;
	while (curr != nullptr)
	{
		pushBack(curr->data);
		curr = curr->next;
	}
}
template<class T>
void List<T>::erase()
{
	Element<T>* curr;
	while (first != nullptr)
	{
		curr = first;
		first = first->next;
		delete curr;
	}
	first = last = nullptr;
	count = 0;
}
template<class T>
List<T>::List()
{
	first = nullptr;
	last = nullptr;
	count = 0;
}
template<class T>
List<T>::List(const List<T> &other)
{
	cpy(other);
}
template<class T>
List<T>& List<T>:: operator=(const List<T>&other)
{
	if (first == other.first) return *this;
	erase();
	cpy(other);
	return*this;
}
template<class T>
List<T>::~List()
{
	erase();
}

template<class T>
void List<T>::reverse(Element<T> *&start)
{
	Element<T>*previous = nullptr;
	Element<T>*current = start;
	Element<T>*incoming;
	while (current)
	{
		incoming = current->next;
		current->next = previous;
		previous = current;
		current = incoming;
	}
	start = previous;
}
template<class T>
void List<T>::ascending(Element<T> one)
{
	Element<T>*current = one.start;
	Element<T>*incoming = current->next;
	Element<T>*helper;
	while (incoming)
	{
		if (current->data > incoming->data)
		{
			helper = current;
			current = incoming;
			incoming = helper;
		}
		current = current->next;
	}
}
template<class T>
List<T> List<T>::merge(Element<T> one, Element<T> other)
{
	Element<T> result;
	Element<T>*current = other.start;
	while (current->next) 
	{
		ascending(other);
	}
	Element<T>* last;
	while (current->next) 
	{
		last = current->next;
		current = current->next;
	}
	last->next = other.start;
	while (current->next)
	{
		ascending(last);
	}
}
template<class T>
void List<T>::iterator(Element<T>* p)
{
	if (p)
		current = p;
	else
	{
		current = start;
	}
}

template<class T>
Element<T>* List<T>::iter() //returns current positiion of iterator and moves it with one position
{
	Element<T>*p = current;
	if (current)
	{
		current = current->next;
	}
	return p;
}


int main()
{

	return 0;
}
